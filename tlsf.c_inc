/**
 * @file
 * @brief Implementation of TLSF memory allocation algorithm.
 * @section LICENSE
 *
 * MIT License
 *
 * Copyright (c) 2019 Hattori, Hiroki
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @section Usage
 *
 * ```` your_c_source.c
 * #define TLSF_FFS(x)    __builtin_ffsl(x)
 * #define TLSF_CLZ(x)    __builtin_clzl(x)
 * #define TLSF_SLSHIFT   (2)
 * #define TLSF_PREFIX    my_
 * // #define TLSF_DEBUG       (1)
 * // #define TLSF_WARN_HANDLER     printf
 * // #define TLSF_EXTRA_ZONEDATA_T  struct my_extra_data
 * // #define NDEBUG         (1)
 * #include "somewherepath/tlsf.c_inc"
 * ````
 *
 * ```` youe_c_header.h
 * #define TLSF_PREFIX    my_
 * #define TLSF_DECL_ONLY (1)
 * #include "somewherepath/tlsf.c_inc"
 * #undef TLSF_PREFIX
 * #undef TLSF_DECL_ONLY
 * ````
 *
 * @section Configuration variable.
 *
 * - TLSF_FFS(x)
 *
 *   Your own find-first-set function. Or, __builtin_ffsl for gcc.
 *
 * - TLSF_CLZ(x)
 *
 *   Your own count-leading-zeros function, Or, __builtin_clz for gcc.
 *
 * - TLSF_SLSHIFT
 *
 *   Number of bits for second level index. You can use zero for single level
 *   mode.
 *
 * - TLSF_PREFIX
 *
 *   Custom prefix of function and types.
 *
 * - TLSF_DEBUG
 *
 *   Define (1) to enable internal debugging code. 0 or undefine to disable.
 *
 * - TLSF_WARN_HANDLER(fmt, ...)
 *
 *   Warnning message handler for non-fatal error case.
 *   undefine to supress it.
 *
 * - TLSF_EXTRA_ZONEDATA_T
 *
 *   Add extra data to zone header. You can access it with cast the zone
 *   pointer. Undefine to ommit it.
 *
 *  - NDEBUG
 *
 *   You can ommit parameter checker from all APIs.
 *
 * @section Chunk layout
 *   1. mysize + magic   (0 = tail)
 *   2. prevsize         (0 = head)
 *   3. nextchunk
 *   4. prevchunk
 *
 * @section APIs
 *
 * @fn [PREFIX]tlsf_zone_t [PREFIX]tlsf_create_zone(void *start, size_t nbytes)
 * @brief Create new heap zone.
 * @param start    Pointer to free memory space.
 * @param nbytes   Size of memory space.
 * @return a zone handle. Or, NULL for too small memory size.
 *
 * You can cast that zone handle to TLSF_EXTRA_ZONEDATA_T* to access your
 * custom data.
 *
 * @fn size_t [PREFIX]tlsf_add_block(void *start, size_t nbytes, [PREFIX]tlsf_zone_t zone)
 * @brief Extend free space with another memory space.
 * @param start    Pointer to free memory space.
 * @param nbytes   Size of memory space.
 * @param zone     Zone handle.
 * @returns Actual extended size in bytes. 0 for too small memory size.
 *
 * @fn void *[PREFIX]tlsf_alloc(size_t nbytes, [PREFIX]tlsf_zone_t zone)
 * @brief Allocate memory chunk.
 * @param nbytes    Bytes to allocate.
 * @param zone      Zone handle.
 * @return Pointer to allocated space. Or NULL for exhausted.
 *
 * @fn void [PREFIX]tlsf_free(void *ptr, [PREFIX]tlsf_zone_t zone)
 *
 */

#include <stddef.h>


#define TLSF_GLUE2(x, y)       x##y
#define TLSF_GLUE3(x, y)       TLSF_GLUE2(x, y)
#define TLSF_GLUE(x)           TLSF_GLUE3(TLSF_PREFIX, x)

#define TLSF_ZONE              TLSF_GLUE(tlsf_zone)
#define TLSF_ZONE_T            TLSF_GLUE(tlsf_zone_t)
#define TLSF_FREE              TLSF_GLUE(tlsf_free)
#define TLSF_ALLOC             TLSF_GLUE(tlsf_alloc)
#define TLSF_CREATE_ZONE       TLSF_GLUE(tlsf_create_zone)
#define TLSF_ADD_BLOCK         TLSF_GLUE(tlsf_add_block)
#define TLSF_CONFIG            TLSF_GLUE(tlsf_config)
#define TLSF_CONFIG_TAG        TLSF_GLUE(tlsf_config_tag)

struct TLSF_CONFIG_TAG {
  size_t unit_size;
  size_t zone_header_size;
  size_t zone_extra_data_size;
  unsigned char fl_shift;
  unsigned char sl_shift;
  unsigned char machine_alignment;
};


/* ************************************************************************ */
/* Declaration section */
#if defined(TLSF_DECL_ONLY) && TLSF_DECL_ONLY
#  if defined(__cplusplus)
extern "C" {
#  endif


typedef struct TLSF_ZONE TLSF_ZONE_T;
void *TLSF_ALLOC(void *start, size_t nbytes, TLSF_ZONE_T zone);
void TLSF_FREE(void *ptr, TLSF_ZONE_T zone);
int TLSF_ADD_BLOCK(void *start, size_t nbytes, TLSF_ZONE_T zone);
TLSF_ZONE_T TLSF_CREATE_ZONE(void *start, size_t nbytes);

extern struct TLSF_CONFIG_TAG TLSF_CONFIG;

#  if defined(__cplusplus)
}
#  endif
#else
/* ************************************************************************ */
/* Implementation section */
#  include <stdint.h>
#  include <memory.h>
#  include <assert.h>

#  if defined(__cplusplus)
extern "C" {
#  endif

#  define TLSF_FLSHIFT  (sizeof(size_t) * 8 - TLSF_SLSHIFT - 1)
#  define TLSF_SLDEPTH  (1 << TLSF_SLSHIFT)
#  define TLSF_SLMAPSIZE   ((TLSF_FLSHIFT - ((TLSF_UNIT_ALIGN==4)?2:(TLSF_UNIT_ALIGN==8)?3:0)) * TLSF_SLDEPTH)
#  define TLSF_SIZET_MAGIC0 ((size_t)1 << (sizeof(size_t) * 8 - 1))
#  define TLSF_SIZET_MAGIC1 ((size_t)1 << (sizeof(size_t) * 8 - 2))
#  define TLSF_SIZET_MAGIC  ((size_t)3 << (sizeof(size_t) * 8 - 2))
#  if defined(TLSF_DEBUG) && TLSF_DEBUG
#    define TLSF_ASSERT(x)   do { assert(x); } while (0)
#  else
#    define TLSF_ASSERT      do { } while (0)
#  endif
#  if defined(TLSF_WARN_HANDLER)
#    define TLSF_WARN(fmt, ...)  do { TLSF_WARN_HANDLER(fmt, __VA_ARGS__); } while (0)
#  else
#    define TLSF_WARN(fmt, ...)  do { } while (0)
#  endif



static_assert(sizeof(size_t) * 8 > 3, "well, ...you compilers broken.");
static_assert(TLSF_SLSHIFT >= 0
           && TLSF_SLSHIFT < sizeof(size_t) * 8 - 2, "Bad TLSF_SLSHIFT");
static_assert(TLSF_SLSHIFT == 0 || sizeof(uintptr_t) * 8 % TLSF_SLDEPTH == 0,
    "Unsupported case.");


#  define TLSF_UNIT_T   union TLSF_PREFIX##tlsf_unit
TLSF_UNIT_T { size_t sz; TLSF_UNIT_T *ptr; };
static_assert(sizeof(TLSF_UNIT_T) >= 4, "No magic space of size_t.");
#  define TLSF_UNIT_ALIGN    (sizeof(TLSF_UNIT_T))



#  define TLSF_MAPPING_INSERT   TLSF_GLUE(tlsf_mapping_insert)
static inline unsigned int TLSF_MAPPING_INSERT(size_t nunits) {
  unsigned char f = TLSF_FLSHIFT - TLSF_CLZ((nunits - 1) | ((TLSF_SLDEPTH << 1) -1));
  unsigned char s = ((nunits - 1) >> (f?f:1)) & (TLSF_SLDEPTH - 1);
  return (f << TLSF_SLSHIFT) + s;
}




typedef struct TLSF_ZONE {
#  if defined(TLSF_EXTRA_ZONEDATA_T)
  TLSF_EXTRA_ZONEDATA_T extra;
#  endif

#  if (TLSF_SLSHIFT > 0)
  size_t flmap;
#  endif
  uintptr_t slmap[
    (TLSF_SLMAPSIZE + sizeof(uintptr_t) * 8 - 1) / (sizeof(uintptr_t) * 8)];
  TLSF_UNIT_T *frees[TLSF_SLMAPSIZE];
  TLSF_UNIT_T firstchunk[];
} *TLSF_ZONE_T;



struct TLSF_CONFIG_TAG TLSF_CONFIG = {
  .unit_size = sizeof(TLSF_UNIT_T),
  .zone_header_size = sizeof(struct TLSF_ZONE),
#  if defined(TLSF_EXTRA_ZONEDATA_T)
  .zone_extra_data_size = sizeof(TLSF_EXTRA_ZONEDATA_T),
#  else
  .zone_extra_data_size = 0,
#endif
  .fl_shift = TLSF_FLSHIFT,
  .sl_shift = TLSF_SLSHIFT,
  .machine_alignment = TLSF_UNIT_ALIGN,
};




#  define TLSF_ADD_CHUNK     TLSF_GLUE(tlsf_add_chunk)
static void TLSF_ADD_CHUNK(TLSF_UNIT_T *chunk, TLSF_ZONE_T zone) {
  TLSF_ASSERT(zone != NULL);
  TLSF_ASSERT((chunk[0].sz & TLSF_SIZET_MAGIC) == 0);

  unsigned int const ix = TLSF_MAPPING_INSERT(chunk[0].sz);
  chunk[0].sz |= TLSF_SIZET_MAGIC1;
  TLSF_UNIT_T *nxt = zone->frees[ix];
  if (nxt == NULL) {
    chunk[2].ptr = chunk;
    chunk[3].ptr = chunk;

    // Mark bitmap as available.
    size_t const bw = sizeof(uintptr_t) * 8;
    zone->slmap[ix / bw] |= (uintptr_t)1 << (ix % bw);
#if (TLSF_SLSHIFT > 0)
    zone->flmap |= (size_t)1 << (ix >> TLSF_SLSHIFT);
#endif
  } else {
    TLSF_UNIT_T *prv = nxt[3].ptr;
    chunk[2].ptr = nxt;
    chunk[3].ptr = prv;
    nxt[3].ptr = chunk;
    prv[2].ptr = chunk;
  }
  zone->frees[ix] = chunk;
  //printf("%s: units=%lu ix=%lu flmap=%lx nxt=%p\n", __FUNCTION__,
  //    (chunk[0].sz & ~TLSF_SIZET_MAGIC), x.ix, zone->flmap, nxt);
}



#  define TLSF_REMOVE_CHUNK  TLSF_GLUE(tlsf_remove_chunk)
static void TLSF_REMOVE_CHUNK(TLSF_UNIT_T *chunk, TLSF_ZONE_T zone) {
  TLSF_ASSERT(zone != NULL);
  TLSF_ASSERT(chunk); // it coruppsed.
  TLSF_ASSERT((chunk[0].sz & TLSF_SIZET_MAGIC0) == 0); // it coruppsed.

  chunk[3].ptr[2].ptr = chunk[2].ptr; // chunk->prv->next = chunk->next
  chunk[2].ptr[3].ptr = chunk[3].ptr; // chunk->next->prv = chunk->prv
  if (chunk[0].sz & TLSF_SIZET_MAGIC1) { // it's first chunk.
    chunk[0].sz &= ~TLSF_SIZET_MAGIC;

    unsigned int const ix = TLSF_MAPPING_INSERT(chunk[0].sz);
    TLSF_ASSERT(zone->frees[ix] == chunk);
    if (chunk[2].ptr == chunk) { // to be empty.
      zone->frees[ix] = NULL;

      // Mark bitmap as unavalable.
      size_t const bw = sizeof(uintptr_t) * 8;
      zone->slmap[ix / bw] &= ~((uintptr_t)1 << (ix % bw));
#if (TLSF_SLSHIFT > 0)
      uintptr_t const msk = (((uintptr_t)1 << TLSF_SLSHIFT) - 1) << ((ix & ~(TLSF_SLDEPTH - 1)) % bw);
      if (! (zone->slmap[ix / bw] & msk))
        zone->flmap &= ~((size_t)1 << (ix >> TLSF_SLSHIFT));
#endif
    } else {
      zone->frees[ix] = chunk[2].ptr;
      chunk[2].ptr[0].sz |= TLSF_SIZET_MAGIC1;
    }
  }
  //printf("%s: flmap=%lx\n", __FUNCTION__, zone->flmap);
}





void *TLSF_ALLOC(size_t nbytes, TLSF_ZONE_T zone) {
  assert(zone != NULL);
  assert(nbytes > 0);

  size_t nunits = (nbytes + sizeof(TLSF_UNIT_T) - 1) / sizeof(TLSF_UNIT_T);
  if (nunits < 2) nunits = 2; // Minimum allocation size is 2.

  unsigned int const ix = ({
    unsigned char f = TLSF_FLSHIFT - TLSF_CLZ((nunits - 1) | ((TLSF_SLDEPTH << 1)- 1));
    TLSF_MAPPING_INSERT(nunits + (((size_t)1 << (f?f:1)) - 1)); });

  size_t const bw = sizeof(uintptr_t) * 8;
  unsigned int const iy = TLSF_FFS(zone->slmap[ix / bw] & ((uintptr_t)-1 << (ix % bw)) );
  TLSF_UNIT_T *p;
  if (iy) {
    p = zone->frees[(ix & ~(bw - 1)) + iy - 1];
  } else {
#if (TLSF_SLSHIFT > 0)
    unsigned char fli = TLSF_FFS(zone->flmap & ((size_t)-2 << (ix >> TLSF_SLSHIFT)));
    if (fli == 0) {
      TLSF_WARN("%s: No space left. for %lu bytes", __FUNCTION__, nbytes);
      return NULL;
    }
    --fli;

    TLSF_ASSERT(fli <= TLSF_FLSHIFT);
    TLSF_ASSERT(fli > (ix >> TLSF_SLSHIFT));

    unsigned int const iz = TLSF_FFS(zone->slmap[fli * TLSF_SLDEPTH / bw]);
    TLSF_ASSERT(iz != 0);
    p = zone->frees[fli * TLSF_SLDEPTH + iz - 1];
#else
    TLSF_WARN("%s: No space left. for %lu bytes", __FUNCTION__, nbytes);
    return NULL;
#endif
  }
  //printf("%s: allocating %lu units from %lu.\n", __FUNCTION__, nunits, (p[0].sz & ~TLSF_SIZET_MAGIC));

  TLSF_ASSERT(p != NULL);
  TLSF_REMOVE_CHUNK(p, zone);
  TLSF_ASSERT((p[0].sz & TLSF_SIZET_MAGIC) == 0);
  TLSF_ASSERT(p[0].sz >= nunits);

  if (p[0].sz >= nunits + 2 + 4) {
    TLSF_UNIT_T *q = p + 2  + nunits;
    q[0].sz = p[0].sz - 2 - nunits;
    p[2 + p[0].sz + 1].sz = q[0].sz;
    q[1].sz = nunits;
    p[0].sz = nunits;
    TLSF_ADD_CHUNK(q, zone);
    //printf("%s:    it take %lu units back (flmap=%lx).\n", __FUNCTION__,
    //    (q[0].sz & ~TLSF_SIZET_MAGIC), zone->flmap);
  }

  p[0].sz |= TLSF_SIZET_MAGIC0;  // Mark as used.
  return (void*)(p + 2);
}




void TLSF_FREE(void *ptr, TLSF_ZONE_T zone) {
  assert(zone != NULL);
  assert(ptr != NULL);

  TLSF_UNIT_T *p = (TLSF_UNIT_T*)ptr - 2;
  p[0].sz &= ~TLSF_SIZET_MAGIC0;

  TLSF_UNIT_T *const ql = p - p[1].sz - 2;
  TLSF_UNIT_T *const qr = p + p[0].sz + 2;

  // Merge right.
  if (qr[0].sz != 0 && !(qr[0].sz & TLSF_SIZET_MAGIC0)) {
    TLSF_REMOVE_CHUNK(qr, zone);
    p[0].sz += qr[0].sz;
    qr[2 + qr[0].sz + 1].sz = p[0].sz;
  }

  // Merge left.
  if (ql[1].sz != 0 && !(ql[0].sz & TLSF_SIZET_MAGIC0)) {
    TLSF_REMOVE_CHUNK(ql, zone);
    ql[0].sz += p[0].sz;
    p[2 + p[0].sz + 1].sz = ql[0].sz;
    p = ql;
  }

  TLSF_ADD_CHUNK(p, zone);
}



size_t TLSF_ADD_BLOCK(void *start, size_t nbytes, TLSF_ZONE_T zone) {
  assert(start != NULL);
  assert(zone != NULL);

  uintptr_t tail = (uintptr_t)start + nbytes;
  TLSF_UNIT_T *p = (TLSF_UNIT_T*)(((uintptr_t)start + TLSF_UNIT_ALIGN - 1) & ~(TLSF_UNIT_ALIGN - 1));
  unsigned int n = (tail - (uintptr_t)p) / sizeof(TLSF_UNIT_T);
  if (n < 5) {
    TLSF_WARN("%s: Too small block size. start=%p; nbytes=%lu (%u units).\n",
      __FUNCTION__, start, nbytes, n);
    return 0;
  }

  p[0].sz = n - 3;
  p[1].sz = 0;
  p[n - 1].sz = 0;
  TLSF_ADD_CHUNK(p, zone);

  return (n - 3) * sizeof(TLSF_UNIT_T);
}



TLSF_ZONE_T TLSF_CREATE_ZONE(void *start, size_t nbytes) {
  assert(start != NULL);
  assert((uintptr_t)start <= (uintptr_t)(void*)-1 - nbytes);

  uintptr_t tail = (uintptr_t)start + nbytes;
  TLSF_ZONE_T zone = (TLSF_ZONE_T)(((uintptr_t)start + TLSF_UNIT_ALIGN - 1) & ~(TLSF_UNIT_ALIGN - 1));
  TLSF_ASSERT((uintptr_t)zone >= (uintptr_t)start);
  size_t skip = (uintptr_t)zone - (uintptr_t)start;

  if (nbytes < sizeof(struct TLSF_ZONE) + skip) {
    TLSF_WARN("%s: Too small block size. start=%p; nbytes=%lu;"
              " %lu bytes dropped for alignment; need %lu bytes at least.\n",
        __FUNCTION__, start, nbytes, skip, sizeof(struct TLSF_ZONE));
    return NULL;
  }
  memset(zone, 0, sizeof(*zone));

  if ((tail - (uintptr_t)zone->firstchunk) >= 5 * sizeof(TLSF_UNIT_T))
    TLSF_ADD_BLOCK(zone->firstchunk, tail - (uintptr_t)zone->firstchunk, zone);

  return zone;
}


#  undef TLSF_FLSHIFT
#  undef TLSF_SLDEPTH
#  undef TLSF_SLMAPSIZE
#  undef TLSF_SIZET_MAGIC0
#  undef TLSF_SIZET_MAGIC1
#  undef TLSF_SIZET_MAGIC
#  undef TLSF_ASSERT
#  undef TLSF_WARN
#  undef TLSF_TPL3
#  undef TLSF_UNIT_T
#  undef TLSF_UNIT_ALIGN

#  undef TLSF_MAPPING_INSERT
#  undef TLSF_ADD_CHUNK
#  undef TLSF_REMOVE_CHUNK

#  if defined(__cplusplus)
}
#  endif
#endif


#undef TLSF_ZONE
#undef TLSF_ZONE_T
#undef TLSF_FREE
#undef TLSF_ALLOC
#undef TLSF_CREATE_ZONE
#undef TLSF_ADD_BLOCK
#undef TLSF_CONFIG
#undef TLSF_CONFIG_TAG

#undef TLSF_GLUE
#undef TLSF_GLUE2
#undef TLSF_GLUE3

// vim: ts=8 sw=2 filetype=c cindent expandtab :
